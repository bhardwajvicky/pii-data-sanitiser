# Workload Distribution & Performance Analysis

## 1. Where Does the Processing Happen?

### **Application Server (Where Our Program Runs)** 🖥️
**PRIMARY WORKLOAD LOCATION**

#### CPU-Intensive Tasks:
- ✅ **Data Transformation**: Converting PII to obfuscated values
- ✅ **Cryptographic Hashing**: SHA-256 for deterministic generation  
- ✅ **Memory Management**: Caching, object creation, garbage collection
- ✅ **Data Validation**: Format checking, length preservation
- ✅ **Batch Processing Logic**: Parallel coordination, thread management

#### Memory Usage:
- **Cache Storage**: 1-2GB for mapping cache (configurable)
- **Batch Buffers**: 100-500MB per processing thread
- **Object Overhead**: ~50-100MB for framework and libraries
- **Total Estimate**: 2-4GB RAM for optimal performance

### **Database Server** 🗄️
**SECONDARY WORKLOAD - I/O FOCUSED**

#### Database Tasks:
- ✅ **Data Reading**: SELECT operations to fetch batches
- ✅ **Data Writing**: UPDATE operations to save obfuscated data
- ✅ **Index Management**: Temporarily disable/rebuild indexes
- ✅ **Transaction Logging**: Recording changes for backup/recovery

#### Database Load Characteristics:
- **CPU**: Low to moderate (mainly I/O coordination)
- **Memory**: Buffer cache for data pages being processed
- **Storage**: High I/O for reading/writing large datasets
- **Network**: Data transfer to/from application server

### **Network Layer** 🌐
- **Data Transfer**: Raw data from DB → App → Transformed data back to DB
- **Bandwidth Usage**: ~10-50 Mbps for typical batch sizes
- **Latency Impact**: Minimal with proper batch sizing

## 2. Performance Optimization Strategy

### **Application Server Optimization**

#### Hardware Recommendations:
```
CPU: 16+ cores (for parallel batch processing)
RAM: 32-64GB (for large caches and multiple threads)
Storage: NVMe SSD (for temp files and swap)
Network: 10Gbps+ (for database communication)
```

#### Software Configuration:
```csharp
// Optimize for CPU-bound workload
var config = new ObfuscationConfig
{
    ParallelThreads = Environment.ProcessorCount, // Use all cores
    BatchSize = 25000, // Larger batches for better CPU utilization
    MaxCacheSize = 5000000, // Large cache to reduce regeneration
    EnableValueCaching = true // Essential for performance
};
```

### **Database Server Optimization**

#### Database Configuration:
```sql
-- Optimize for bulk operations
ALTER DATABASE MyDatabase SET RECOVERY SIMPLE; -- Faster writes
ALTER DATABASE MyDatabase SET READ_COMMITTED_SNAPSHOT ON; -- Reduce blocking

-- Increase batch timeout
SET LOCK_TIMEOUT 600000; -- 10 minutes

-- Temporarily disable constraints for faster updates
ALTER TABLE MyTable NOCHECK CONSTRAINT ALL;
```

#### Index Management Strategy:
```sql
-- Before obfuscation: Drop non-clustered indexes
SELECT 'DROP INDEX ' + i.name + ' ON ' + t.name 
FROM sys.indexes i 
JOIN sys.tables t ON i.object_id = t.object_id 
WHERE i.type > 1; -- Non-clustered indexes

-- After obfuscation: Rebuild all indexes
ALTER INDEX ALL ON MyTable REBUILD;
```

## 3. Workload Distribution Examples

### **Example 1: 1TB Database Processing**

#### Time Distribution:
```
Application Server Processing:
├─ Data Transformation: 60% of total time
├─ Cache Management: 15% of total time  
├─ Batch Coordination: 10% of total time
└─ Network Communication: 15% of total time

Database Server Processing:
├─ Data Reading: 40% of DB time
├─ Data Writing: 50% of DB time
└─ Index/Constraint Management: 10% of DB time
```

#### Resource Utilization:
```
Application Server:
├─ CPU: 80-95% utilization across all cores
├─ Memory: 4-8GB active usage
└─ Network: 20-100 Mbps sustained

Database Server:  
├─ CPU: 30-50% utilization (I/O bound)
├─ Memory: Buffer pool intensive
└─ Storage: 200-500 IOPS per processing thread
```

### **Example 2: Scaling Considerations**

#### Single Application Server:
- **Throughput**: 100,000-250,000 rows/minute
- **CPU Bound**: Application server becomes bottleneck
- **Database Impact**: Moderate (can handle load easily)

#### Multiple Application Servers:
```csharp
// Table partitioning for multiple servers
Server 1: Tables 1-300 (alphabetically)
Server 2: Tables 301-600
Server 3: Tables 601-900

// Or by data volume
Server 1: Small tables (<100K rows)
Server 2: Medium tables (100K-1M rows)  
Server 3: Large tables (1M+ rows)
```

## 4. Monitoring & Resource Management

### **Application Server Monitoring**
```csharp
public class ResourceMonitor
{
    public void LogResourceUsage()
    {
        var process = Process.GetCurrentProcess();
        Console.WriteLine($"""
            CPU Usage: {GetCpuUsage()}%
            Memory: {process.WorkingSet64 / 1024 / 1024}MB
            Threads: {process.Threads.Count}
            Cache Size: {_provider.GetAllMappings().Count:N0}
            """);
    }
}
```

### **Database Server Monitoring**
```sql
-- Monitor database performance
SELECT 
    db_name() as DatabaseName,
    (SELECT COUNT(*) FROM sys.dm_exec_requests WHERE database_id = DB_ID()) as ActiveConnections,
    (SELECT COUNT(*) FROM sys.dm_exec_sessions WHERE database_id = DB_ID()) as TotalSessions

-- Monitor I/O statistics
SELECT 
    database_id,
    file_id,
    num_of_reads,
    num_of_writes,
    io_stall_read_ms,
    io_stall_write_ms
FROM sys.dm_io_virtual_file_stats(NULL, NULL);
```

## 5. Network Optimization

### **Batch Size Impact on Network**
```
Small Batches (1,000 rows):
├─ More network round trips
├─ Higher overhead per row
└─ Better for real-time monitoring

Large Batches (50,000 rows):
├─ Fewer network round trips  
├─ Better throughput
└─ Higher memory usage
```

### **Connection Pooling Configuration**
```csharp
var connectionString = new SqlConnectionStringBuilder
{
    DataSource = "database-server",
    InitialCatalog = "MyDatabase",
    IntegratedSecurity = true,
    Pooling = true,
    MinPoolSize = 10,
    MaxPoolSize = 100,
    ConnectionTimeout = 30,
    CommandTimeout = 600 // 10 minutes for large batches
};
```

## 6. Cost-Benefit Analysis

### **Processing Location Trade-offs**

#### ✅ **Application Server Processing (Current Approach)**
**Pros:**
- Database server remains available for other operations
- Can scale application servers independently  
- Better resource utilization (CPU vs I/O separation)
- Easier debugging and monitoring
- Supports complex transformation logic

**Cons:**
- Network bandwidth usage for data transfer
- Additional infrastructure (application servers)
- Memory requirements on application servers

#### ❌ **Database Server Processing (Alternative)**
**Pros:**
- No network transfer overhead
- Single point of processing

**Cons:**
- Database server becomes unavailable during processing
- Limited by database server CPU/memory
- Complex transformation logic difficult in SQL
- Harder to scale and monitor
- Risk to production database stability

## 7. Recommended Architecture

### **Optimal Setup for 1TB+ Database**
```
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│  Load Balancer  │    │  App Server 1    │    │   Database      │
│                 │◄──►│  (Tables 1-300)  │◄──►│   Server        │
└─────────────────┘    └──────────────────┘    │                 │
                                               │  High I/O       │
┌──────────────────┐    ┌──────────────────┐    │  Configuration  │
│  App Server 2    │    │  App Server 3    │    │                 │
│  (Tables 301-600)│◄──►│  (Tables 601-900)│◄──►│                 │
└──────────────────┘    └──────────────────┘    └─────────────────┘
```

### **Performance Expectations**
- **Single App Server**: 8-24 hours for 1TB
- **3 App Servers**: 3-8 hours for 1TB  
- **Database Load**: 30-50% CPU, high I/O
- **Network Usage**: 50-200 Mbps sustained

This architecture maximizes throughput while keeping the database responsive for other operations.